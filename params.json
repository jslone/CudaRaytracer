{"name":"Raytracer","tagline":"CMU 15-418 - Adaptive Assignment for Real Time Raytracing","body":"## Proposal\r\n### Summary\r\nWe are going to implement adaptive thread-block assignment for a real-time GPU raytracer and profile its performance. We will create a BVH accelerated raytracer and implement at least two methods for optimizing thread-block assignment at runtime: hill climbing on the dimensions of blocks and spatial reassignment of rays to threads during traces. We will then profile the performance of each combination of these two methods.\r\n\r\n### Background\r\nRaytracing is a hot topic in computer graphics capable of producing much higher fidelity images than traditional rendering methods. The basic idea is that we can determine how a scene looks by simulating how photons bounce through the scene. Generally, this is simplified slightly by backtracking from the camera to find which photons could possibly reach the camera.\r\n\r\nWhile parallelizing raytracing is rather trivial (simply parallelize across the rays), doing so efficiently on a GPU is more challenging due to ray divergence. We hope to minimize the costs of ray divergence by performing dynamic optimization on thread-block assignment used during tracing. This includes performing basic hill climbing on our initial dimensions at the start of a trace as well as leveraging our spatial data structure to reallocate rays among CUDA threads in order to optimize memory access and SIMD coherency on each block.\r\n\r\nThe idea is that by ensuring our blocks consists of threads tracing rays through a single spatial region ensures high SIMD coherency and our blocks can efficiently use shared memory since each ray will be checking collisions with the same objects.\r\n\r\n### The Challenge\r\n- Efficiently updating rays in the spatial data structure after a trace step\r\n- Minimizing discrepancy between the times each block takes to execute\r\n- Minimizing the latency between trace steps\r\n\r\n### Resources\r\n- GHC Cluster NVIDIA GPUs\r\n- Personal NVIDIA GPU\r\n- Starter Code\r\n    - References\r\n        - PBRT code\r\n        - 15-462 starter code\r\n    - Existing Code to be Used\r\n        - SDL: Used for cross platform drawing and input\r\n        - GLM: Used for vector and matrix operations\r\n        - TinyXML: Used for loading scenes created in xml from multiple objects\r\n        - tinyobjloader: Used for loading 3d objects to be rendered\r\n\r\n### Goals and Deliverables\r\n- Functional real-time GPU raytracer\r\n- Report on analysis of different optimizations\r\n\r\n### Grade Proposal\r\nGrade | Project Status\r\n------|-----------------------------------------------------------------------------------\r\nA+    | Feature complete raytracer (caustics/volumetric scattering/sub-surface scattering)\r\nA     | Profiling and analysis\r\nA-    | Dynamic ray assignment\r\nB     | Optimized data structure\r\nC     | Create functional (unoptimized) parallel raytracer with hill climbing\r\n\r\n### Platform Choice\r\nWe chose CUDA as our platform of choice as its massive parallelism with relatively low latency makes\r\nit the best candidate for real time ray tracing, but there are still many interesting challenges with\r\nutilizing it effectively which we would like to explore. This makes the assignment more interesting\r\nto us than a CPU implementation, as a GPU implementation could in theory be much faster if usage was\r\noptimal.\r\n\r\n### Schedule\r\n- Week of April 10\r\n    - Scene parsing\r\n- Week of April 17\r\n    - Functional (unoptimized) raytracer\r\n    - Hill climbing\r\n-Week of April 24\r\n    - Optimized data structure\r\n    - Dynamic ray assignment\r\n- Week of May 1\r\n    - Final debugging\r\n- Week of May 8\r\n    - Profile/Analysis \r\n\r\n### Team\r\nJacob Slone [jslone] @jslone\r\n\r\nPaul Aluri [paluri] @paulaluri","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}